"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs = __importStar(require("fs"));
const util_1 = require("util");
const vm2_1 = require("vm2");
const phin = require("phin")
    .defaults({ "parse": "json", "timeout": 12000 });
const Game_1 = __importDefault(require("./class/Game"));
const Team_1 = __importDefault(require("./class/Team"));
const Brick_1 = __importDefault(require("./class/Brick"));
const Bot_1 = __importDefault(require("./class/Bot"));
const PacketBuilder_1 = __importDefault(require("./net/PacketBuilder"));
const Vector3_1 = __importDefault(require("./class/Vector3"));
const scripts_1 = require("./scripts");
const Tool_1 = __importDefault(require("./class/Tool"));
const Outfit_1 = __importDefault(require("./class/Outfit"));
const colorModule_1 = __importDefault(require("./util/color/colorModule"));
const filterModule_1 = __importDefault(require("./util/filter/filterModule"));
const serializerModule_1 = __importDefault(require("./util/serializer/serializerModule"));
const NPM_LATEST_VERSION = "https://registry.npmjs.org/node-hill/latest";
const CORE_DIRECTORY = path_1.resolve(__dirname, "./core_scripts");
function vmLoadScriptInDirectory(vm, scriptDirectory, scriptType) {
    fs.readdirSync(scriptDirectory).forEach((file) => {
        if (Game_1.default.coreScriptsDisabled.includes(file))
            return console.log(`[*] Disabled Core Script: ${file}`);
        try {
            const scriptPath = path_1.resolve(scriptDirectory, file);
            const scriptContents = fs.readFileSync(scriptPath, "UTF-8");
            vm.run(scriptContents, scriptPath);
            console.log(`[*] Loaded ${scriptType} Script: ${file}`);
        }
        catch (err) {
            console.log(`[*] Error loading ${scriptType} Script: ${file}`);
            console.error(err.stack);
        }
    });
}
function loadScripts() {
    const sandbox = {
        Game: Game_1.default,
        world: Game_1.default.world,
        Team: Team_1.default,
        Brick: Brick_1.default,
        Bot: Bot_1.default,
        Outfit: Outfit_1.default,
        util: { color: colorModule_1.default, filter: filterModule_1.default, serializer: serializerModule_1.default },
        Tool: Tool_1.default,
        PacketBuilder: PacketBuilder_1.default,
        sleep: util_1.promisify(setTimeout),
        Vector3: Vector3_1.default,
        debounce: (func, wait) => {
            let timeout;
            return function () {
                if (timeout)
                    return;
                timeout = setTimeout(() => {
                    timeout = null;
                }, wait);
                func.apply(this, arguments);
            };
        }
    };
    const VM_SETTINGS = {
        require: {
            external: true,
            context: "sandbox",
            builtin: [
                "assert",
                "http",
                "https",
                "net",
                "readline",
                "zlib",
                "url",
                "querystring",
                "path"
            ]
        },
        sandbox: Object.assign(Object.assign({}, sandbox), Game_1.default.sandbox)
    };
    const vm = new vm2_1.NodeVM(VM_SETTINGS);
    if (Game_1.default.coreScriptsDisabled[0] !== "*")
        vmLoadScriptInDirectory(vm, CORE_DIRECTORY, "Core");
    else
        console.log("[*] All Core Scripts disabled");
    if (!Game_1.default.userScripts)
        return;
    vmLoadScriptInDirectory(vm, Game_1.default.userScripts, "User");
}
function initiateMap(map) {
    const mapName = path_1.basename(map);
    if (!mapName.endsWith(".brk")) {
        console.log("Map selected is not a .brk file. Aborting.");
        return process.exit(0);
    }
    console.clear();
    Game_1.default.mapName = mapName;
    try {
        const { environment, bricks, tools, teams, spawns } = scripts_1.loadBrk(map);
        Game_1.default.world.environment = environment;
        Game_1.default.world.bricks = bricks;
        Game_1.default.world.spawns = spawns;
        Game_1.default.world.tools = tools;
        Game_1.default.world.teams = teams;
    }
    catch (err) {
        console.error("Failure parsing brk: ", err && err.stack);
        return process.exit(1);
    }
    console.log(`Selected: <Port: ${Game_1.default.port} | Game: ${Game_1.default.gameId} | Map: ${Game_1.default.mapName}>`);
}
function startServer(settings) {
    if (!settings.port || isNaN(settings.port)) {
        console.log("No port specified. Defaulted to 42480.");
        settings.port = 42480;
    }
    if (!settings.gameId || isNaN(settings.gameId)) {
        console.log("No game ID specified.");
        return process.exit(0);
    }
    if (settings.scripts)
        settings.scripts = path_1.resolve(process.cwd(), settings.scripts);
    Game_1.default.port = settings.port;
    Game_1.default.gameId = settings.gameId;
    Game_1.default.coreScriptsDisabled = settings.coreScriptsDisabled || [];
    Game_1.default.userScripts = settings.scripts;
    Game_1.default.sandbox = settings.sandbox || {};
    Game_1.default.local = settings.local || false;
    if (!settings.map) {
        console.warn("No map loaded. Using default baseplate.");
        Game_1.default.map = false;
    }
    else {
        settings.map = path_1.resolve(process.cwd(), settings.map);
        Game_1.default.map = settings.map;
        initiateMap(Game_1.default.map);
    }
    Game_1.default.serverSettings = Object.assign({}, settings);
    _getLatestnpmVersion().then((package_version) => {
        if (package_version !== Game_1.default.version) {
            console.warn(`Your node-hill version is out of date. [Latest version: ${package_version}]. \nRun \`npm update\` to resolve.`);
        }
    }).catch(() => {
        console.warn("Failure while checking for latest node-hill version.");
    });
    require("./server");
    loadScripts();
}
exports.startServer = startServer;
function _getLatestnpmVersion() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = (yield phin({ url: NPM_LATEST_VERSION })).body;
        return data.version;
    });
}
module.exports = { startServer };
