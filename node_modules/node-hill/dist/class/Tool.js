"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Game_1 = __importDefault(require("./Game"));
const toolPacket = require("../scripts/tools/tool");
var ToolEvents;
(function (ToolEvents) {
    ToolEvents["Activated"] = "activated";
    ToolEvents["Equipped"] = "equipped";
    ToolEvents["Unequipped"] = "unequipped";
})(ToolEvents || (ToolEvents = {}));
class Tool extends events_1.EventEmitter {
    constructor(name) {
        super();
        this.enabled = true;
        this.model = 0;
        Tool.toolId += 1;
        this.name = name;
        this.model = 0;
        this.enabled = true;
        this._slotId = Tool.toolId;
    }
    addListener(event, listener) { return super.addListener(event, listener); }
    unequipped(callback) {
        const toolEvent = (p) => {
            callback(p);
        };
        this.on("unequipped", toolEvent);
        return {
            disconnect: () => this.off("unequipped", toolEvent)
        };
    }
    equipped(callback) {
        const toolEvent = (p) => {
            callback(p);
        };
        this.on("equipped", toolEvent);
        return {
            disconnect: () => this.off("equipped", toolEvent)
        };
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            for (let player of Game_1.default.players) {
                if (player.toolEquipped === this) {
                    player.toolEquipped = null;
                    this.emit("unequipped", player);
                }
                yield player.destroyTool(this);
            }
            const index = Game_1.default.world.tools.indexOf(this);
            if (index === -1)
                return;
            Game_1.default.world.tools.splice(index, 1);
            this.removeAllListeners();
            return toolPacket.destroy(this)
                .broadcast();
        });
    }
}
exports.default = Tool;
Tool.toolId = 0;
Tool.activated = ToolEvents.Activated;
Tool.equipped = ToolEvents.Equipped;
Tool.unequipped = ToolEvents.Unequipped;
