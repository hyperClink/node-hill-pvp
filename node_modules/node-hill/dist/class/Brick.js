"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const Game_1 = __importDefault(require("./Game"));
const brickIds_1 = __importDefault(require("../net/BrickHillPackets/brickIds"));
const Vector3_1 = __importDefault(require("./Vector3"));
const TOUCH_EVENTS = ["touching", "touchingEnded"];
class Brick extends events_1.EventEmitter {
    constructor(position = new Vector3_1.default(0, 0, 0), scale = new Vector3_1.default(1, 1, 1), color = "#C0C0C0") {
        super();
        this.lightEnabled = false;
        this.lightColor = "#000000";
        this.lightRange = 5;
        this.visibility = 0;
        this.collision = true;
        this.clickable = false;
        this.clickDistance = 50;
        Brick.brickId += 1;
        this.destroyed = false;
        this._steps = [];
        this.position = position;
        this.scale = scale;
        this.color = color;
        this.lightColor = "#000000";
        this.lightRange = 5;
        this.visibility = 1;
        this.netId = Brick.brickId;
        this.collision = true;
        this.lightEnabled = false;
        this._playersTouching = new Set();
        this._hitMonitorActive = false;
        this.on("newListener", (event) => {
            if (!TOUCH_EVENTS.includes(event))
                return;
            if (!this._hitMonitorActive) {
                this._detectTouching();
                this._hitMonitorActive = true;
            }
        });
        this.on("removeListener", (event) => {
            if (event !== "touching")
                return;
            if (this.listenerCount("touching"))
                return;
            clearInterval(this._hitMonitor);
            this._hitMonitorActive = false;
        });
    }
    get center() {
        return new Vector3_1.default(this.position.x + this.scale.x / 2, this.position.y + this.scale.y / 2, this.scale.z);
    }
    setPosition(position) {
        return __awaiter(this, void 0, void 0, function* () {
            this.position = new Vector3_1.default().fromVector(position);
            return brickIds_1.default(this, "pos");
        });
    }
    setScale(scale) {
        return __awaiter(this, void 0, void 0, function* () {
            this.scale = new Vector3_1.default().fromVector(scale);
            return brickIds_1.default(this, "scale");
        });
    }
    setRotation(rot) {
        return __awaiter(this, void 0, void 0, function* () {
            this.rotation = rot;
            return brickIds_1.default(this, "rot");
        });
    }
    setModel(model) {
        return __awaiter(this, void 0, void 0, function* () {
            this.model = model;
            return brickIds_1.default(this, "model");
        });
    }
    setColor(color) {
        return __awaiter(this, void 0, void 0, function* () {
            this.color = color;
            return brickIds_1.default(this, "col");
        });
    }
    setLightColor(color) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.lightEnabled)
                return Promise.reject("brick.lightEnabled must be enabled first!");
            this.lightColor = color;
            return brickIds_1.default(this, "lightcol");
        });
    }
    setLightRange(range) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.lightEnabled)
                return Promise.reject("brick.lightEnabled must be enabled first!");
            this.lightRange = range;
            return brickIds_1.default(this, "lightrange");
        });
    }
    setVisibility(visibility) {
        return __awaiter(this, void 0, void 0, function* () {
            this.visibility = visibility;
            return brickIds_1.default(this, "alpha");
        });
    }
    setCollision(collision) {
        return __awaiter(this, void 0, void 0, function* () {
            this.collision = collision;
            return brickIds_1.default(this, "collide");
        });
    }
    setClickable(clickable, clickDistance = 50) {
        return __awaiter(this, void 0, void 0, function* () {
            this.clickable = clickable;
            this.clickDistance = clickDistance;
            return brickIds_1.default(this, "clickable");
        });
    }
    setInterval(callback, delay) {
        let loop = setInterval(callback, delay);
        this._steps.push(loop);
        return loop;
    }
    clone() {
        let newBrick = new Brick(this.position, this.scale, this.color);
        newBrick.name = this.name;
        newBrick.lightColor = this.lightColor;
        newBrick.clickable = this.clickable;
        newBrick.clickDistance = this.clickDistance;
        newBrick.visibility = this.visibility;
        newBrick.collision = this.collision;
        newBrick.lightEnabled = this.lightEnabled;
        return newBrick;
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.destroyed)
                return Promise.reject("Brick has already been destroyed.");
            clearInterval(this._hitMonitor);
            this.removeAllListeners();
            this._steps.forEach((loop) => {
                clearInterval(loop);
            });
            if (!this.socket) {
                const bricks = Game_1.default.world.bricks;
                const index = bricks.indexOf(this);
                if (index !== -1)
                    bricks.splice(index, 1);
            }
            else {
                const locals = this.socket.player.localBricks;
                const index = locals.indexOf(this);
                if (index !== -1)
                    locals.splice(index, 1);
            }
            if (!this.collision)
                yield this.setCollision(true);
            yield brickIds_1.default(this, "destroy");
            this.socket = undefined;
            this.netId = undefined;
            this._playersTouching = new Set();
            this.destroyed = true;
        });
    }
    _hitDetection() {
        let scale = [];
        let origin = [];
        scale[0] = this.scale.x / 2;
        scale[1] = this.scale.y / 2;
        scale[2] = this.scale.z / 2;
        origin[0] = this.position.x + scale[0];
        origin[1] = this.position.y + scale[1];
        origin[2] = this.position.z + scale[2];
        const players = (this.socket && [this.socket.player]) || Game_1.default.players;
        for (const p of players) {
            let size = [];
            size[0] = p.scale.x;
            size[1] = p.scale.y;
            size[2] = 5 * p.scale.z / 2;
            let center = [];
            center[0] = p.position.x;
            center[1] = p.position.y;
            center[2] = p.position.z + size[2];
            let touched = true;
            for (let i = 0; i < 3; i++) {
                let dist = Math.abs(origin[i] - center[i]);
                let close = size[i] + scale[i];
                if (dist >= close + 0.4) {
                    touched = false;
                }
            }
            if (touched && p.alive) {
                this._playersTouching.add(p);
                this.emit("touching", p);
            }
            if (this._playersTouching.has(p) && (!touched || !p.alive)) {
                this._playersTouching.delete(p);
                this.emit("touchingEnded", p);
            }
        }
    }
    clicked(callback) {
        if (!this.clickable)
            this.setClickable(true, this.clickDistance);
        let clickEvent = (p) => {
            let secure = false;
            if ((Math.pow(this.position.x - p.position.x, 2) +
                Math.pow(this.position.y - p.position.y, 2) +
                Math.pow(this.position.z - p.position.z, 2)) <= this.clickDistance)
                secure = true;
            callback(p, secure);
        };
        this.on("clicked", clickEvent);
        return {
            disconnect: () => {
                this.off("clicked", clickEvent);
                this.setClickable(false);
                return null;
            }
        };
    }
    touchingEnded(callback) {
        let touchEvent = (p) => {
            callback(p);
        };
        this.on("touchingEnded", touchEvent);
        return {
            disconnect: () => this.off("touchingEnded", touchEvent)
        };
    }
    touching(callback) {
        let touchEvent = (p) => {
            callback(p);
        };
        this.on("touching", touchEvent);
        return {
            disconnect: () => this.off("touching", touchEvent)
        };
    }
    _detectTouching() {
        this._hitMonitor = setInterval(() => {
            for (let p of this._playersTouching) {
                if (p.destroyed) {
                    this._playersTouching.delete(p);
                }
            }
            if (!Game_1.default.playerCount)
                return;
            this._hitDetection();
        }, 100);
    }
}
exports.default = Brick;
Brick.brickId = 0;
